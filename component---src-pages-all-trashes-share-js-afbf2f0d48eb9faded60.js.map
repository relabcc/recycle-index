{"version":3,"sources":["webpack:///./node_modules/react-window/dist/index.esm.js","webpack:///./src/containers/TrashPage/PageExplode.js","webpack:///./src/containers/TrashPage/Page1.js","webpack:///./src/containers/TrashPage/PageShare.js","webpack:///./src/containers/TrashPage/AllPage.js","webpack:///./src/pages/allTrashes/share.js","webpack:///./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","webpack:///./node_modules/memoize-one/dist/memoize-one.esm.js","webpack:///./src/components/FullpageHeight.js","webpack:///./node_modules/ios-inner-height/dist/ios-inner-height.js"],"names":["now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","requestAnimationFrame","tick","call","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","createElement","outerStyle","style","width","height","overflow","direction","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","defaultItemKey","_ref","columnIndex","data","rowIndex","createGridComponent","_ref2","_class","_temp","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","Grid","props","_this","this","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","_this$props","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","key","hasOwnProperty","_offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","_event$currentTarget","currentTarget","clientHeight","clientWidth","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","_proto","prototype","scrollTo","_ref3","scrollToItem","_ref4","_ref4$align","align","_this$props2","columnCount","rowCount","_this$state","scrollbarSize","div","offsetWidth","getScrollbarSize","estimatedTotalHeight","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_this$props3","_callPropsCallbacks","componentDidUpdate","_this$state2","componentWillUnmount","render","_this$props4","children","className","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","_this$_getHorizontalR","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_this$_getVerticalRan","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","_rowIndex","_columnIndex","push","estimatedTotalWidth","WebkitOverflowScrolling","willChange","pointerEvents","_this$props5","_this$_getHorizontalR2","_overscanColumnStartIndex","_overscanColumnStopIndex","_visibleColumnStartIndex","_visibleColumnStopIndex","_this$_getVerticalRan2","_overscanRowStartIndex","_overscanRowStopIndex","_visibleRowStartIndex","_visibleRowStopIndex","_this$state3","_horizontalScrollDirection","_scrollLeft","_scrollTop","_scrollUpdateWasRequested","_verticalScrollDirection","_this$props6","overscanColumnCount","overscanColumnsCount","overscanCount","_this$state4","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","_this$props7","overscanRowCount","overscanRowsCount","_this$state5","defaultProps","_ref5","_ref6","FixedSizeGrid","index","_ref7","instanceProps","lastColumnOffset","maxOffset","minOffset","middleOffset","round","ceil","floor","_ref8","lastRowOffset","_ref9","_ref10","numVisibleColumns","_ref11","_ref12","numVisibleRows","_ref13","theTimeline","TrashDescription","Box","Absolute","bottom","responsive","Text","lineHeight","letterSpacing","textAlign","fontSize","colorsCfg","A","B","C","withData","isMobile","useResponsive","colorScheme","recycleValue","trashWidth","isIos","transform","scale","mobileScale","xRange","faceId","useMemo","faceNo","useLoader","img","n","String","padStart","parts","imgs","map","i","src","FullAbs","BackgroundImage","ratio","imgSize","pt","theme","headerHeight","onClick","window","open","process","PUBLIC_URL","location","search","cursor","transformOrigin","Container","Number","textStroke","textStrokeColor","color","AbsCenter","size","as","name","length","fontWeight","description","zIndex","Relative","mobileFirstY","Face","face","trashData","containerWidth","useContext","containerWidthContext","endTransition","mobileX","mobileY","x","y","endPos","bg","px","mx","shareBgMobile","shareBg","share","Flex","justifyContent","mt","mr","FB","border","rounded","Line","pb","flexDirection","pr","Handling","steps","handling","alternative","flex","pl","borderTop","borderLeft","alignItems","my","Image","planb","planbBubble","rotate","mobileRotate","d","join","shareScale","mobileShareScale","logo","alt","TrashName","SectionTitle","TrashNote","TrashNumber","windowSize","page","faceRef","useRef","trashRef","trashXRef","layerRefs","createRef","animaRefs","partsRefs","explosionGap","gap","pos","linePos","centeroid","partName","side","theSide","whiteSpace","Circle","opacity","partsDetail","borderColor","belongsTo","recycleRate","RateCircle","value","useEffect","kill","defaultTrashCfg","gsap","set","rateEles","timeline","onUpdate","forEach","ele","e","Event","progress","time","dispatchEvent","newHeight","totalHeight","partsCount","yStart","animation","animations","explodeWidthFactor","innerHeight","explosionScale","to","duration","cfg","positions","order","layerName","Object","entries","ani","querySelector","scrollingDuration","rateEle","tweenTo","partsNote","Cell","Page1","pageContext","ShareCell","PageShare","ExplodedCell","PageExplode","BelongsCell","AllPage","exploded","useWindowSize","useData","filteredData","filter","images","perRow","_assertThisInitialized","self","ReferenceError","areInputsEqual","newInputs","lastInputs","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","_i","arguments","apply","Fullpage","forwardRef","hideHeader","headerContext","getCurrentValue","module","exports","r","t","o","f","u","a","Error","code","p","1","require","navigator","userAgent","match","ruler","axis","abs","orientation","dims","w","h","documentElement","offsetHeight","innerWidth"],"mappings":"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","file":"component---src-pages-all-trashes-share-js-afbf2f0d48eb9faded60.js","sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose'; // Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\n\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\n\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\n\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class, _temp;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _temp = _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent); // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n\n\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _temp;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class, _temp;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _temp = _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent); // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n\n\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var itemCount = this.props.itemCount;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1));\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemCount = _this$props4.itemCount,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _temp;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n}); // Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\n\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n} // It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, [\"style\"]);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, [\"style\"]);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n} // It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { VariableSizeGrid, VariableSizeList, FixedSizeGrid, FixedSizeList, areEqual, shouldComponentUpdate };","import React, { useEffect, useRef, useState, useMemo, createRef, useContext } from 'react'\r\nimport { AspectRatio } from '@chakra-ui/react'\r\nimport gsap from 'gsap'\r\nimport innerHeight from 'ios-inner-height'\r\n\r\nimport Box from '../../components/Box'\r\nimport Text from '../../components/Text'\r\nimport Circle from '../../components/Circle'\r\nimport Container from '../../components/Container'\r\nimport BackgroundImage from '../../components/BackgroundImage'\r\nimport withData from './data/withData';\r\nimport animations from './data/animations'\r\nimport RateCircle from './RateCircle';\r\nimport Face from '../Face';\r\n\r\nimport containerWidthContext from '../../contexts/containerWidth/context'\r\nimport useResponsive from '../../contexts/mediaQuery/useResponsive';\r\nimport theme, { responsive } from '../../components/ThemeProvider/theme';\r\nimport useLoader from '../../utils/useLoader';\r\nimport imgSize from './data/imgSize'\r\nimport isIos from '../../components/utils/isIos'\r\n\r\n// const pageCount = 5\r\nconst scrollingDuration = 1\r\nconst idealWidth = 200\r\n\r\nlet theTimeline\r\n\r\nconst TrashName = ({ children, ...props }) => (\r\n  <Box.Absolute\r\n    top={responsive('4.5em', '1.25em')}\r\n    left={responsive('2em', '0.625em')}\r\n    color=\"white\"\r\n    {...props}\r\n  >\r\n    <Text fontSize={responsive('4em', '1.5625em')} fontWeight=\"900\" letterSpacing=\"0.1em\">{children}</Text>\r\n  </Box.Absolute>\r\n)\r\n\r\nconst SectionTitle = ({ children, ...props }) => (\r\n  <Box.Absolute left={responsive('2em', '0.625em')} top={responsive('10.5em', '3.4375em')} {...props}>\r\n    <Text fontSize={responsive('2em', '0.9375em')}>{children}</Text>\r\n  </Box.Absolute>\r\n)\r\n\r\nconst TrashNote = ({ children, ...props }) => children && (\r\n  <Box.Absolute top={responsive('4em', 'auto')} bottom={responsive('auto', '1.25em')} right={responsive('6%', '3.75em')} width={responsive('50%', '33%')}>\r\n    <Text textAlign=\"right\" fontSize={responsive('2.5em', '1em')} {...props}>\r\n      *{children}\r\n    </Text>\r\n  </Box.Absolute>\r\n)\r\n\r\nconst TrashNumber = ({ children, ...props }) => (\r\n  <Box.Absolute\r\n    bottom={responsive('auto', '1.25em')}\r\n    top={responsive('0em', 'auto')}\r\n    left={responsive('2em', '0.625em')}\r\n    color=\"white\"\r\n    {...props}\r\n  >\r\n    <Text.Number fontSize={responsive('3.5em', '1.09375em')}>{children}</Text.Number>\r\n  </Box.Absolute>\r\n)\r\n\r\nconst colorsCfg = {\r\n  A: 'green',\r\n  B: 'orange',\r\n  C: 'pink',\r\n}\r\n\r\nconst TrashPage = ({ data, windowSize, page }) => {\r\n  const { isMobile } = useResponsive()\r\n  const { containerWidth } = useContext(containerWidthContext)\r\n  // setup refs\r\n  const faceRef = useRef()\r\n  const trashRef = useRef()\r\n  const trashXRef = useRef()\r\n  const layerRefs = useMemo(() => data.imgs.map(() => createRef()), [data])\r\n  const animaRefs = useMemo(() => data.imgs.map(() => createRef()), [data])\r\n  const partsRefs = useMemo(() => data.imgs.map(() => createRef()), [data])\r\n\r\n  const colorScheme = `colors.${colorsCfg[data.recycleValue]}`\r\n  const trashWidth = (isMobile ? (isIos ? 140 : 160) : 75) * (data.transform.scale ? (isMobile && data.transform.mobileScale ? data.transform.mobileScale : data.transform.scale) / 100 : Math.min(1, idealWidth / (data.xRange[1] - data.xRange[0])))\r\n  const explosionGap = (isMobile ? 10 : 5) * (100 + (data.transform.gap || 0)) / 100\r\n\r\n  useLoader(data.img)\r\n  const n = `#${String(data.id).padStart(3, '0')}`\r\n\r\n  const parts = useMemo(() => {\r\n    if (!data) return null\r\n    return data.imgs.map(({ src, centeroid, x, width, partName, side }, i) => {\r\n      let pos\r\n      let linePos\r\n      const theSide = isMobile ? 0 : side\r\n\r\n      if (partName) {\r\n        pos = theSide ? (x * 1 + width * 1) / imgSize[0] * 100 + 3 : (1 - x / imgSize[0]) * 100 + 3\r\n        linePos = theSide ? {\r\n          left: `${pos}%`,\r\n          right: `${100 - pos}%`\r\n        } : {\r\n          right: `${pos}%`,\r\n          left: `${100 - pos}%`\r\n        }\r\n      }\r\n      const top = `${centeroid[1] / imgSize[1] * 100}%`\r\n      return (\r\n        <Box.FullAbs ref={layerRefs[i]} key={i}>\r\n          <BackgroundImage ref={animaRefs[i]} ratio={imgSize[0] / imgSize[1]} src={src} />\r\n          {partName && (\r\n            <Box ref={partsRefs[i]}>\r\n              {/* <Box.Absolute\r\n                top={top}\r\n                left={`${left}%`}\r\n                width=\"0.5em\"\r\n                height=\"0.5em\"\r\n                transform=\"translate(-50%, -50%)\"\r\n                bg=\"black\"\r\n              /> */}\r\n              <Box.Absolute\r\n                top={top}\r\n                style={linePos}\r\n                height=\"2px\"\r\n                bg={colorScheme}\r\n                className=\"line\"\r\n              />\r\n              <Box.Absolute\r\n                top={top}\r\n                style={{ [theSide ? 'left' : 'right'] : `${pos}%` }}\r\n                transform=\"translateY(-50%)\"\r\n                whiteSpace=\"nowrap\"\r\n                className=\"circle-container\"\r\n                pointerEvents=\"all\"\r\n              >\r\n                <Circle\r\n                  bg={colorScheme}\r\n                  width={responsive('20em', '7.5em')}\r\n                  textAlign=\"center\"\r\n                  className=\"circle-1\"\r\n                  whiteSpace=\"pre-wrap\"\r\n                  opacity={0}\r\n                >\r\n                  <Text color=\"black\" fontSize={responsive('3em', '0.9375em')} fontWeight=\"900\">{partName}</Text>\r\n                  <Text color=\"white\" fontSize={responsive('2em', '0.78125em')}>{data.partsDetail[partName]}</Text>\r\n                </Circle>\r\n                <Box.FullAbs className=\"circle-2\" transform=\"scale(0)\">\r\n                  <Circle border=\"2px solid\" borderColor={colorScheme} bg=\"white\" width=\"100%\" textAlign=\"center\" whiteSpace=\"pre-wrap\">\r\n                    <Text color=\"black\" fontSize={responsive('3em', '0.9375em')} fontWeight=\"900\">{data.belongsTo[partName]}</Text>\r\n                    {data.recycleRate[data.belongsTo[partName]] && (\r\n                      <Text color={colorScheme} fontSize={responsive('2em', '0.78125em')} fontWeight=\"900\">回收率{data.recycleRate[data.belongsTo[partName]]}%</Text>\r\n                    )}\r\n                  </Circle>\r\n                </Box.FullAbs>\r\n                <Box.Absolute className=\"circle-rate\" opacity=\"0\" left=\"-8%\" right=\"-8%\" top=\"-8%\" bottom=\"-8%\" pointerEvents=\"none\">\r\n                  {data.recycleRate[data.belongsTo[partName]] && (\r\n                    <RateCircle className=\"circle-rate-progress\" value={data.recycleRate[data.belongsTo[partName]]} color={colorScheme} />\r\n                  )}\r\n                </Box.Absolute>\r\n              </Box.Absolute>\r\n            </Box>\r\n          )}\r\n        </Box.FullAbs>\r\n      )\r\n    })\r\n  }, [data])\r\n\r\n  // const pageRevealRefs = useMemo(() => range(pageCount).map(() => createRef()), [])\r\n  useEffect(() => {\r\n    if (theTimeline) {\r\n      theTimeline.kill()\r\n    }\r\n    // set trash size\r\n    const defaultTrashCfg = { width: `${trashWidth}%`, left: `${(100 - trashWidth) / 2}%`, rotate: (isMobile && data.transform.mobileRotate ? data.transform.mobileRotate : data.transform.rotate) || 0 }\r\n    gsap.set(trashRef.current, defaultTrashCfg)\r\n    const rateEles = []\r\n\r\n    theTimeline = gsap.timeline({\r\n      onUpdate: () => {\r\n        if (rateEles.length) {\r\n          rateEles.forEach((ele) => {\r\n            const e = new Event('progress')\r\n            e.progress = Math.min(1, Math.max(0, theTimeline.time() - 2))\r\n            ele.dispatchEvent(e)\r\n          })\r\n        }\r\n      },\r\n    })\r\n    // console.log(data)\r\n    const newHeight = data.totalHeight + (data.partsCount - 1) * imgSize[1] * explosionGap / 100\r\n    const yStart = newHeight - (newHeight - imgSize[1]) / 2\r\n    const animation = animations[data.name]\r\n    // set exploded trash size\r\n    const explodeWidthFactor = Math.min(\r\n      Math.floor(((innerHeight() - 60) / (newHeight * (isMobile ? 1.35 : 1.1)) * imgSize[0]) / containerWidth * 100),\r\n      isMobile ? (data.transform.explosionScale || 100) : 50\r\n    )\r\n\r\n    theTimeline.to(faceRef.current, {\r\n      opacity: 0,\r\n      duration: scrollingDuration,\r\n    })\r\n    theTimeline.to(trashRef.current, {\r\n      width: `${explodeWidthFactor}%`,\r\n      left: `${(100 - explodeWidthFactor) / 2}%`,\r\n      x: isMobile ? '25%' : '0',\r\n      // y: isMobile ? '-50%' : 0,\r\n      top: isMobile ? '50%' : '50%',\r\n      duration: scrollingDuration,\r\n    }, scrollingDuration)\r\n\r\n    data.imgs.forEach((cfg) => {\r\n      gsap.set(layerRefs[cfg.index].current, { y: '0%' })\r\n      // calc parts y position\r\n      theTimeline.to(layerRefs[cfg.index].current, {\r\n        y: `${(yStart - cfg.y - data.positions[cfg.order] - imgSize[1] * explosionGap / 100 * cfg.order) / imgSize[1] * 100}%`,\r\n        duration: scrollingDuration,\r\n      }, scrollingDuration)\r\n      if (animation && animation[cfg.layerName]) {\r\n        Object.entries(animation[cfg.layerName]).forEach(([d, ani]) => {\r\n          theTimeline.to(animaRefs[cfg.index].current, {\r\n            ...ani,\r\n            duration: scrollingDuration * (d / 100),\r\n          }, scrollingDuration)\r\n        })\r\n      }\r\n      if (cfg.partName) {\r\n        theTimeline.to(partsRefs[cfg.index].current.querySelector('.circle-container'), {\r\n          [cfg.side && !isMobile ? 'left' : 'right']: isMobile ? '92%' : '100%',\r\n          duration: scrollingDuration,\r\n        }, scrollingDuration)\r\n        theTimeline.to(partsRefs[cfg.index].current.querySelector('.line'), {\r\n          [cfg.side && !isMobile ? 'right' : 'left']: '-2%',\r\n          opacity: 1,\r\n          duration: scrollingDuration,\r\n        }, scrollingDuration)\r\n        theTimeline.to(partsRefs[cfg.index].current.querySelector('.circle-1'), {\r\n          opacity: 1,\r\n          duration: scrollingDuration,\r\n        }, scrollingDuration)\r\n        theTimeline.to(partsRefs[cfg.index].current.querySelector('.circle-2'), {\r\n          scale: 1,\r\n          duration: scrollingDuration,\r\n        }, 2 * scrollingDuration)\r\n        theTimeline.to(partsRefs[cfg.index].current.querySelector('.circle-rate'), {\r\n          opacity: 1,\r\n          duration: scrollingDuration / 2,\r\n        }, 2.5 * scrollingDuration)\r\n        const rateEle = partsRefs[cfg.index].current.querySelector('.circle-rate-progress')\r\n        if (rateEle) {\r\n          rateEles.push(rateEle)\r\n        }\r\n      }\r\n    })\r\n    theTimeline.tweenTo(page, { duration: 1 })\r\n  }, [data, windowSize.height, containerWidth])\r\n  return (\r\n    <Box\r\n      height=\"100vh\"\r\n      width=\"100vw\"\r\n      onClick={() => window.open(`${process.env.PUBLIC_URL}${window.location.search}/#/trash/${data.id}`)}\r\n      cursor=\"pointer\"\r\n      transformOrigin=\"0 0\"\r\n      transform=\"scale(0.5)\"\r\n      pt={theme.headerHeight}\r\n      bg={colorScheme}\r\n    >\r\n      <Box.Relative height=\"100%\" bg=\"white\">\r\n        <Box.Absolute\r\n          top=\"0\"\r\n          left=\"0\"\r\n          right=\"0\"\r\n          height=\"100%\"\r\n          zIndex=\"docked\"\r\n          pointerEvents=\"none\"\r\n        >\r\n          <Container height=\"100%\">\r\n            <Box.Relative height=\"100%\">\r\n            <Box.Absolute\r\n              ref={trashRef}\r\n              id=\"trash-container\"\r\n              top={responsive('45%', '50%')}\r\n              transform=\"translate3d(0, -50%, 0)\"\r\n              width={`${trashWidth}%`}\r\n              left={`${(100 - trashWidth) / 2}%`}\r\n            >\r\n              <div ref={trashXRef}>\r\n                <AspectRatio ratio={imgSize[0] / imgSize[1]} overflow=\"visible\">\r\n                  <Box overflow=\"visible\">\r\n                    {parts}\r\n                  </Box>\r\n                </AspectRatio>\r\n              </div>\r\n            </Box.Absolute>\r\n            <TrashName color={colorScheme}>{data.name}</TrashName>\r\n            <SectionTitle>組成的材質是什麼？</SectionTitle>\r\n            <TrashNumber color={colorScheme}>{n}</TrashNumber>\r\n            <TrashNote color={colorScheme}>\r\n              {data.partsNote}\r\n            </TrashNote>\r\n            </Box.Relative>\r\n          </Container>\r\n        </Box.Absolute>\r\n      </Box.Relative>\r\n    </Box>\r\n  )\r\n}\r\n\r\nexport default withData(TrashPage)\r\n","import React, { useMemo } from 'react'\r\nimport { AspectRatio } from '@chakra-ui/react'\r\nimport { random } from 'lodash'\r\nimport { SizeMe } from 'react-sizeme';\r\n\r\nimport Box from '../../components/Box'\r\nimport Text from '../../components/Text'\r\nimport Container from '../../components/Container'\r\nimport BackgroundImage from '../../components/BackgroundImage'\r\nimport withData from './data/withData';\r\nimport Face from '../Face';\r\n\r\nimport useResponsive from '../../contexts/mediaQuery/useResponsive';\r\nimport theme, { responsive } from '../../components/ThemeProvider/theme';\r\nimport useLoader from '../../utils/useLoader';\r\nimport imgSize from './data/imgSize'\r\nimport isIos from '../../components/utils/isIos'\r\n\r\nconst idealWidth = 200\r\n\r\nconst TrashDescription = (props) => (\r\n  <Box.Absolute bottom={responsive('9%', '10%')} right={responsive('10%', '6em')} width={responsive('80%', '30%')}>\r\n    <Text lineHeight=\"1.625\" letterSpacing=\"0.075em\" textAlign=\"justify\" fontSize={responsive('2.5em', '1em')} {...props} />\r\n  </Box.Absolute>\r\n)\r\n\r\nconst colorsCfg = {\r\n  A: 'green',\r\n  B: 'orange',\r\n  C: 'pink',\r\n}\r\n\r\nconst TrashPage = ({ data }) => {\r\n  const { isMobile } = useResponsive()\r\n  const colorScheme = `colors.${colorsCfg[data.recycleValue]}`\r\n  const trashWidth = (isMobile ? (isIos ? 140 : 160) : 75) * (data.transform.scale ? (isMobile && data.transform.mobileScale ? data.transform.mobileScale : data.transform.scale) / 100 : Math.min(1, idealWidth / (data.xRange[1] - data.xRange[0])))\r\n\r\n  const faceId = useMemo(() => data.transform.faceNo || (random(4) + 1), [data])\r\n  useLoader(data.img)\r\n\r\n  const n = `#${String(data.id).padStart(3, '0')}`\r\n  // const bgColor = get(theme, `colors.${colorScheme}`)\r\n  const parts = useMemo(() => {\r\n    if (!data) return null\r\n    return data.imgs.map(({ src }, i) => (\r\n      <Box.FullAbs key={i}>\r\n        <BackgroundImage ratio={imgSize[0] / imgSize[1]} src={src} />\r\n      </Box.FullAbs>\r\n  ))\r\n  }, [data])\r\n  return (\r\n    <Box\r\n      position=\"relative\"\r\n      width=\"100vw\"\r\n      height=\"100vh\"\r\n      pt={theme.headerHeight}\r\n      onClick={() => window.open(`${process.env.PUBLIC_URL}${window.location.search}/#/trash/${data.id}`)}\r\n      cursor=\"pointer\"\r\n      transformOrigin=\"0 0\"\r\n      transform=\"scale(0.33)\"\r\n    >\r\n      <Container position=\"relative\" height=\"100%\">\r\n        <Box.Absolute left=\"0.625em\" top=\"0em\">\r\n          <Text.Number\r\n            textStroke=\"0.15625rem\"\r\n            textStrokeColor={`colors.${colorScheme}`}\r\n            color=\"white\"\r\n            fontSize=\"6.25em\"\r\n          >{n}</Text.Number>\r\n        </Box.Absolute>\r\n        <Box.AbsCenter top={responsive('15%', '40%')} width=\"100%\" textAlign=\"center\" transform=\"rotate(-12deg)\">\r\n          <SizeMe>\r\n            {({ size }) => (\r\n              <Text\r\n                as=\"h2\"\r\n                color={colorScheme}\r\n                fontSize={size.width ? `${Math.min(Math.floor(size.width / (data.name.length + 1)), size.width / 4) * 3}px` : 0}\r\n                fontWeight=\"900\"\r\n              >\r\n                {data.name}\r\n              </Text>\r\n            )}\r\n          </SizeMe>\r\n        </Box.AbsCenter>\r\n        <TrashDescription color={colorScheme}>\r\n          {data.description}\r\n        </TrashDescription>\r\n      </Container>\r\n      <Box.Absolute\r\n        top=\"0\"\r\n        left=\"0\"\r\n        right=\"0\"\r\n        height=\"100%\"\r\n        zIndex=\"docked\"\r\n        pointerEvents=\"none\"\r\n      >\r\n        <Container position=\"relative\" height=\"100%\">\r\n        <Box.Relative height=\"100%\">\r\n            <Box.Absolute\r\n              id=\"trash-container\"\r\n              top={responsive(`${45 + (data.transform.mobileFirstY || 0)}%`, '50%')}\r\n              transform=\"translate3d(0, -50%, 0)\"\r\n              width={`${trashWidth}%`}\r\n              left={`${(100 - trashWidth) / 2}%`}\r\n            >\r\n              <div>\r\n                <AspectRatio ratio={imgSize[0] / imgSize[1]} overflow=\"visible\">\r\n                  <Box overflow=\"visible\">\r\n                    {parts}\r\n                    <Face transform={data.transform.face} id={faceId} />\r\n                  </Box>\r\n                </AspectRatio>\r\n              </div>\r\n            </Box.Absolute>\r\n          </Box.Relative>\r\n        </Container>\r\n      </Box.Absolute>\r\n    </Box>\r\n  )\r\n}\r\n\r\nexport default withData(TrashPage)\r\n","import React, { useEffect, useRef, useState, useMemo, createRef, forwardRef, useContext } from 'react'\nimport { AspectRatio } from '@chakra-ui/react'\nimport { get, random, range, sampleSize } from 'lodash'\nimport gsap from 'gsap'\nimport { useWindowSize } from 'react-use';\nimport { SizeMe } from 'react-sizeme';\nimport ReactFullpage from '@fullpage/react-fullpage'\nimport 'fullpage.js/vendors/scrolloverflow'\nimport { timer } from 'd3-timer';\n\nimport FullpageHeight from '../../components/FullpageHeight'\nimport Box from '../../components/Box'\nimport Text from '../../components/Text'\nimport Image from '../../components/Image'\nimport Flex from '../../components/Flex'\nimport Circle from '../../components/Circle'\nimport Container from '../../components/Container'\nimport BackgroundImage from '../../components/BackgroundImage'\nimport withData from './data/withData';\nimport animations from './data/animations'\nimport ChevDown from './ChevDown';\nimport Hashtag from './Hashtag';\nimport RateCircle from './RateCircle';\nimport Face from '../Face';\nimport isIos from '../../components/utils/isIos'\n\nimport logo from '../logo.svg'\nimport shareBg from './share-bg.svg'\nimport shareBgMobile from './share-bg-mobile.svg'\nimport Handling from './Handling';\nimport containerWidthContext from '../../contexts/containerWidth/context'\nimport useResponsive from '../../contexts/mediaQuery/useResponsive';\nimport theme, { responsive } from '../../components/ThemeProvider/theme';\nimport useLoader from '../../utils/useLoader';\nimport imgSize from './data/imgSize'\nimport FB from '../../components/Icons/FB';\nimport Line from '../../components/Icons/Line';\nimport planb from './planb.svg'\nimport planbBubble from './planb-bubble.svg'\n\n// const pageCount = 5\nconst idealWidth = 200\n\nconst colorsCfg = {\n  A: 'green',\n  B: 'orange',\n  C: 'pink',\n}\n\nconst TrashPage = ({ trashData: data }) => {\n  const { isMobile } = useResponsive()\n  const { containerWidth } = useContext(containerWidthContext)\n  // setup refs\n  const colorScheme = `colors.${colorsCfg[data.recycleValue]}`\n  const trashWidth = (isMobile ? (isIos ? 140 : 160) : 75) * (data.transform.scale ? (isMobile && data.transform.mobileScale ? data.transform.mobileScale : data.transform.scale) / 100 : Math.min(1, idealWidth / (data.xRange[1] - data.xRange[0])))\n  const faceId = useMemo(() => data.transform.faceNo || (random(4) + 1), [data])\n  const endTransition = [\n    [0 + (data.transform.mobileX || 0), -50 + (data.transform.mobileY || 0)],\n    [-20 + (data.transform.x || 0), -20 + (data.transform.y || 0)],\n  ]\n  const endPos = [containerWidth * 1, containerWidth * 0.25]\n\n  useLoader(data.img)\n\n  return (\n    <Box.Relative\n      height=\"100vh\"\n      width=\"100vw\"\n      pt={theme.headerHeight}\n      transformOrigin=\"0 0\" transform=\"scale(0.5)\"\n      bg={colorScheme}\n      onClick={() => window.open(`${process.env.PUBLIC_URL}${window.location.search}/#/trash/${data.id}`)}\n      cursor=\"pointer\"\n    >\n      <Box bg={colorScheme}>\n        <Container px={responsive(0, '1.25em')}>\n          <Box width={responsive('100%', '50%')} mx=\"auto\" pt={responsive('0', '5vh')}>\n            <BackgroundImage src={isMobile ? shareBgMobile : shareBg} ratio={isMobile ? 750 / 574 : 1368 / 746} overflow=\"visible\">\n              <SizeMe>\n                {({ size }) => (\n                  <Box.Absolute left={responsive('2em', '40%')} top={responsive('8em', '36%')} transform={responsive('', 'trnsateY(-50%)')} width={responsive('55%', '45%')}>\n                    <Box fontSize={`${size.width * 2 / 25}px`}>\n                      <Text letterSpacing=\"0.05em\" fontSize={responsive('1.75em', '2.25em')} fontWeight=\"900\">＃如果你不好好回收</Text>\n                      <Text fontSize={responsive('3.25em', '3.5em')} fontWeight=\"900\" color={colorScheme}>{data.share}</Text>\n                    </Box>\n                  </Box.Absolute>\n                  )}\n              </SizeMe>\n            </BackgroundImage>\n            <Flex fontSize={responsive('3em', '0.625em')} px=\"0.25em\" justifyContent={responsive('', 'flex-end')} mt={responsive('-10%', '-4rem')} mr={responsive(0, '-2rem')}>\n              <FB border=\"1px solid black\" mx=\"0.125em\" rounded=\"0.25em\" />\n              <Line border=\"1px solid black\" mx=\"0.125em\" rounded=\"0.25em\" />\n            </Flex>\n          </Box>\n        </Container>\n\n        <Box\n          bg={colorScheme}\n          pb=\"1em\"\n          pt={responsive('6em', '2em')}\n          position=\"relative\"\n        >\n          <Container px=\"1.25em\">\n            <Flex pt=\"1em\" flexDirection={responsive('column', 'row')}>\n              <Box>\n                <Box pr={responsive(0, '1.5em')}>\n                  <Text fontWeight=\"700\" color=\"white\" fontSize={responsive('3.5em', '1.25em')} letterSpacing=\"0.1em\">＃要給垃圾一個好歸宿，你該這麼做</Text>\n                </Box>\n                <Handling steps={data.handling} />\n              </Box>\n              {data.alternative && (\n                <Box\n                  flex=\"1\"\n                  color=\"white\"\n                  mt={responsive('2.5em', 0)}\n                  pt={responsive('2.5em', 0)}\n                  pl={responsive('0', '1.5em')}\n                  borderTop={responsive('2px solid', 'none')}\n                  borderLeft={responsive('none', '2px solid')}\n                  alignItems={responsive('flex-start', 'center')}\n                >\n                  <Text fontWeight=\"700\" fontSize={responsive('3.5em', '1.25em')} letterSpacing=\"0.1em\">＃或者，你有替代方案：</Text>\n                  <Flex width={responsive('66em', '24em')} mr={responsive('2em', '1em')} alignItems=\"flex-end\" my={responsive('2em', '0.5em')}>\n                    <Box width=\"22%\" pb=\"5%\">\n                      <Image src={planb} />\n                    </Box>\n                    <Box flex=\"1\" pl=\"2%\">\n                      <BackgroundImage src={planbBubble} ratio={486 / 176}>\n                        <Box.Absolute top=\"50%\" left=\"16%\" right=\"5%\" transform=\"translateY(-50%)\">\n                          <Text fontSize={responsive('2.75em', '1em')} letterSpacing=\"0.1em\">{data.alternative}</Text>\n                        </Box.Absolute>\n                      </BackgroundImage>\n                    </Box>\n                  </Flex>\n                </Box>\n              )}\n            </Flex>\n          </Container>\n        </Box>\n      </Box>\n      <Box.Absolute left=\"0\" right=\"0\" top={theme.headerHeight} height={`calc(100vh - ${theme.headerHeight})`} pointerEvents=\"none\">\n          <Container height=\"100%\">\n            <Box.Relative height=\"100%\">\n              <Box.Absolute\n                width={`${trashWidth}%`}\n                left={`${(100 - trashWidth) / 2}%`}\n                top={responsive(`${endPos[0]}px`, `${endPos[1]}px`)}\n                transform={`translate3d(${isMobile ? '10%' : 0}, -50%, 0) ${data.transform.rotate ? `rotate(${isMobile && data.transform.mobileRotate ? data.transform.mobileRotate : data.transform.rotate}deg)` : ''}`}\n              >\n                <Box transform={`translate(${endTransition[isMobile ? 0 : 1].map(d => `${d}%`).join(',')}) ${data.transform.shareScale ? `scale(${(isMobile && data.transform.mobileShareScale ? data.transform.mobileShareScale : data.transform.shareScale) / 100})` : ''}`}>\n                  <BackgroundImage ratio={imgSize[0] / imgSize[1]} src={data.img} />\n                  <Face transform={data.transform.face} id={faceId} />\n                </Box>\n              </Box.Absolute>\n            </Box.Relative>\n          </Container>\n        </Box.Absolute>\n      <Flex position=\"absolute\" top=\"0\" left=\"0\" right=\"0\" height={theme.headerHeight} bg={colorScheme} alignItems=\"center\">\n        <Box px={responsive('2em', '1em')}>\n          <Image width=\"12em\" src={logo} alt=\"回收大百科\" />\n        </Box>\n      </Flex>\n    </Box.Relative>\n  )\n}\n\nexport default withData(TrashPage)\n","import React, { useMemo } from 'react'\nimport { useWindowSize } from 'react-use';\nimport { FixedSizeGrid as Grid } from 'react-window';\n\nimport Box from '../../components/Box'\n\nimport Page1 from './Page1'\nimport PageShare from './PageShare'\nimport PageExplode from './PageExplode'\nimport useData from './data/useData'\nimport images from './data/images'\n\nconst Cell = ({ data, columnIndex, rowIndex, style }) => {\n  const id = rowIndex * 3 + columnIndex\n  const d = data[id]\n  return (\n    <div style={style}>\n      {d ? <Page1 pageContext={ { id: d.id } } /> : null}\n    </div>\n  )\n};\n\nconst ShareCell = ({ data, columnIndex, rowIndex, style }) => {\n  const id = rowIndex * 2 + columnIndex\n  const d = data[id]\n  return (\n    <div style={style}>\n      {d ? <PageShare pageContext={ { id: d.id } } /> : null}\n    </div>\n  )\n};\n\nconst ExplodedCell = ({ data, columnIndex, rowIndex, style }) => {\n  const id = rowIndex * 2 + columnIndex\n  const d = data[id]\n  return d ? (\n    <Box style={style} px=\"1%\">\n      <PageExplode page={2} pageContext={ { id: d.id } } windowSize={{ width: style.width * 0.98, height: style.height }} />\n    </Box>\n  ) : null\n};\n\nconst BelongsCell = ({ data, columnIndex, rowIndex, style }) => {\n  const id = rowIndex * 2 + columnIndex\n  const d = data[id]\n  return d ? (\n    <Box style={style} px=\"1%\">\n      <PageExplode page={3} pageContext={ { id: d.id } } windowSize={{ width: style.width * 0.98, height: style.height }} />\n    </Box>\n  ) : null\n};\n\nconst AllPage = ({ exploded, belongsTo, share }) => {\n  const windowSize = useWindowSize()\n  const data = useData()\n  const filteredData = useMemo(() => {\n    return data ? data.filter(d => {\n      // if (!images[d.name]) console.log(d.name)\n      return images[d.name]\n    }) : []\n  }, [data])\n  const perRow = exploded || belongsTo || share ? 2 : 3\n  let ele = Cell\n  if (exploded) ele = ExplodedCell\n  if (belongsTo) ele = BelongsCell\n  if (share) ele = ShareCell\n  return filteredData.length ? (\n    <Grid\n      columnCount={perRow}\n      columnWidth={windowSize.width / perRow}\n      height={windowSize.height}\n      rowCount={Math.ceil(filteredData.length / perRow)}\n      rowHeight={windowSize.height / perRow}\n      width={windowSize.width}\n      itemData={filteredData}\n    >\n      {ele}\n    </Grid>\n  ) : null\n}\n\nexport default AllPage\n","import React from 'react'\n\nimport Page from '../../containers/TrashPage/AllPage'\n\nexport default () => <Page share />\n","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","function areInputsEqual(newInputs, lastInputs) {\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n\n  for (var i = 0; i < newInputs.length; i++) {\n    if (newInputs[i] !== lastInputs[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n  if (isEqual === void 0) {\n    isEqual = areInputsEqual;\n  }\n\n  var lastThis;\n  var lastArgs = [];\n  var lastResult;\n  var calledOnce = false;\n\n  function memoized() {\n    var newArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newArgs[_i] = arguments[_i];\n    }\n\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult;\n    }\n\n    lastResult = resultFn.apply(this, newArgs);\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    return lastResult;\n  }\n\n  return memoized;\n}\n\nexport default memoizeOne;","import React, { forwardRef, useContext } from 'react';\nimport { useWindowSize } from 'react-use';\n\nimport Box from './Box'\nimport theme from './ThemeProvider/theme'\nimport headerContext from '../contexts/header/context'\nimport useResponsive from '../contexts/mediaQuery/useResponsive'\n\nconst Fullpage = forwardRef(({ children, ...props }, ref) => {\n  const { hideHeader } = useContext(headerContext)\n  const { getCurrentValue } = useResponsive()\n  const headerHeight = getCurrentValue(theme.headerHeight)\n  const windowSize = useWindowSize()\n  return (\n    <Box\n      height={`${windowSize.height}px`}\n      mt={!hideHeader && (!props.position || props.position === 'relative') && `-${headerHeight}`}\n      pt={!hideHeader && headerHeight}\n      top={!hideHeader && props.position === 'fixed' && headerHeight}\n      ref={ref}\n      {...props}\n    >\n      {children}\n    </Box>\n  )\n});\n\nexport default Fullpage;\n","(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.iosInnerHeight = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return c(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n\n        return n[i].exports;\n      }\n\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) {\n        o(t[i]);\n      }\n\n      return o;\n    }\n\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      'use strict';\n      /**\n       * @module ios-inner-height\n       *\n       * @description Get proper window.innerHeight from iOS devices,\n       * excluding URL control and menu bar.\n       *\n       * @return {function} Callable function to retrieve the\n       * cached `window.innerHeight` measurement, specific to the\n       * device's current orientation.\n       */\n\n      module.exports = function () {\n        // Avoid errors when globals are undefined (CI, etc)\n        // https://github.com/tylerjpeterson/ios-inner-height/pull/7\n        if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n          return function () {\n            return 0;\n          };\n        } // Non-iOS browsers return window.innerHeight per usual.\n        // No caching here since browsers can be resized, and setting\n        // up resize-triggered cache invalidation is not in scope.\n\n        /* istanbul ignore if  */\n\n\n        if (!navigator.userAgent.match(/iphone|ipod|ipad/i)) {\n          /**\n           * Avoids conditional logic in the implementation\n           * @return {number} - window's innerHeight measurement in pixels\n           */\n          return function () {\n            return window.innerHeight;\n          };\n        } // Store initial orientation\n\n\n        var axis = Math.abs(window.orientation); // And hoist cached dimensions\n\n        var dims = {\n          w: 0,\n          h: 0\n        };\n        /**\n         * Creates an element with a height of 100vh since iOS accurately\n         * reports vp height (but not window.innerHeight). Then destroy it.\n         */\n\n        var createRuler = function createRuler() {\n          var ruler = document.createElement('div');\n          ruler.style.position = 'fixed';\n          ruler.style.height = '100vh';\n          ruler.style.width = 0;\n          ruler.style.top = 0;\n          document.documentElement.appendChild(ruler); // Set cache conscientious of device orientation\n\n          dims.w = axis === 90 ? ruler.offsetHeight : window.innerWidth;\n          dims.h = axis === 90 ? window.innerWidth : ruler.offsetHeight; // Clean up after ourselves\n\n          document.documentElement.removeChild(ruler);\n          ruler = null;\n        }; // Measure once\n\n\n        createRuler();\n        /**\n         * Returns window's cached innerHeight measurement\n         * based on viewport height and device orientation\n         * @return {number} - window's innerHeight measurement in pixels\n         */\n\n        return function () {\n          if (Math.abs(window.orientation) !== 90) {\n            return dims.h;\n          }\n\n          return dims.w;\n        };\n      }();\n    }, {}]\n  }, {}, [1])(1);\n});"],"sourceRoot":""}